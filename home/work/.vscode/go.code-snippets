{
	"atcoder template": {
		"prefix": "template",
		"body": [
			"package main",
			"",
			"import (",
			"\t\"bufio\"",
			"\t\"fmt\"",
			"\t\"math\"",
			"\t\"math/big\"",
			"\t\"os\"",
			"\t\"strconv\"",
			")",
			"",
			"// 解答欄",
			"func solve(sc *myScanner, wr *myWriter) {",
			"\t$0",
			"}",
			"",
			"// 入出力の準備(sc, wr)",
			"func main() {",
			"\tsc := &myScanner{bufio.NewScanner(os.Stdin)}",
			"\twr := &myWriter{bufio.NewWriter(os.Stdout)}",
			"\tstartBufSize := 4096",
			"\tmaxBufSize := math.MaxInt64",
			"\tsc.Buffer(make([]byte, startBufSize), maxBufSize)",
			"\tsc.Split(bufio.ScanWords)",
			"",
			"\tsolve(sc, wr)",
			"\twr.Flush()",
			"}",
			"",
			"// useful funcs for slice",
			"func makeInts(n, x int) []int {",
			"\tres := make([]int, n)",
			"\tfor i := range res {",
			"\t\tres[i] = x",
			"\t}",
			"\treturn res",
			"}",
			"func makeBools(n int, b bool) []bool {",
			"\tres := make([]bool, n)",
			"\tfor i := range res {",
			"\t\tres[i] = b",
			"\t}",
			"\treturn res",
			"}",
			"func countTrue(bs []bool) int {",
			"\tres := 0",
			"\tfor _, b := range bs {",
			"\t\tif b {",
			"\t\t\tres++",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"",
			"// input",
			"type myScanner struct {",
			"\t*bufio.Scanner",
			"}",
			"",
			"func (sc *myScanner) getInt() int {",
			"\treturn sc._getIntOffset(0)",
			"}",
			"func (sc *myScanner) getInt2() (int, int) {",
			"\treturn sc.getInt(), sc.getInt()",
			"}",
			"func (sc *myScanner) getInt3() (int, int, int) {",
			"\treturn sc.getInt(), sc.getInt(), sc.getInt()",
			"}",
			"func (sc *myScanner) getInt4() (int, int, int, int) {",
			"\treturn sc.getInt(), sc.getInt(), sc.getInt(), sc.getInt()",
			"}",
			"func (sc *myScanner) getInts(n int) []int {",
			"\treturn sc._getIntsOffset(n, 0)",
			"}",
			"func (sc *myScanner) getIntZeroIndexed() int {",
			"\treturn sc._getIntOffset(-1)",
			"}",
			"func (sc *myScanner) getIntsZeroIndexed(n int) []int {",
			"\treturn sc._getIntsOffset(n, -1)",
			"}",
			"func (sc *myScanner) _getIntOffset(x int) int {",
			"\tres, err := strconv.Atoi(sc.getString())",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res + x",
			"}",
			"func (sc *myScanner) _getIntsOffset(n, x int) []int {",
			"\tres := make([]int, n)",
			"\tfor i := range res {",
			"\t\tres[i] = sc._getIntOffset(x)",
			"\t}",
			"\treturn res",
			"}",
			"func (sc *myScanner) getString() string {",
			"\tsc.Scan()",
			"\treturn sc.Text()",
			"}",
			"func (sc *myScanner) getStrings(n int) []string {",
			"\tres := make([]string, n)",
			"\tfor i := range res {",
			"\t\tres[i] = sc.getString()",
			"\t}",
			"\treturn res",
			"}",
			"func (sc *myScanner) getRunes() []rune {",
			"\treturn []rune(sc.getString())",
			"}",
			"func (sc *myScanner) getFloat() float64 {",
			"\tres, err := strconv.ParseFloat(sc.getString(), 64)",
			"\tif err != nil {",
			"\t\tpanic(err)",
			"\t}",
			"\treturn res",
			"}",
			"func (sc *myScanner) getFloats(n int) []float64 {",
			"\tres := make([]float64, n)",
			"\tfor i := range res {",
			"\t\tres[i] = sc.getFloat()",
			"\t}",
			"\treturn res",
			"}",
			"",
			"// output",
			"type myWriter struct {",
			"\t*bufio.Writer",
			"}",
			"",
			"func (wr *myWriter) println(a ...interface{}) {",
			"\tfmt.Fprintln(wr, a...)",
			"}",
			"func (wr *myWriter) printf(format string, a ...interface{}) {",
			"\tfmt.Fprintf(wr, format, a...)",
			"}",
			"",
			"// simple math funcs for int",
			"func max(as ...int) int {",
			"\tres := as[0]",
			"\tfor _, a := range as {",
			"\t\tif res < a {",
			"\t\t\tres = a",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"func min(as ...int) int {",
			"\tres := as[0]",
			"\tfor _, a := range as {",
			"\t\tif res > a {",
			"\t\t\tres = a",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"func chMax(a *int, b int) {",
			"\t*a = max(*a, b)",
			"}",
			"",
			"func chMin(a *int, b int) {",
			"\t*a = min(*a, b)",
			"}",
			"func abs(a int) int {",
			"\tif a < 0 {",
			"\t\treturn -a",
			"\t}",
			"\treturn a",
			"}",
			"func pow(a, n int) int {",
			"\tres := 1",
			"\tb := a",
			"\tfor n > 0 {",
			"\t\tif n&1 > 0 {",
			"\t\t\tres *= b",
			"\t\t}",
			"\t\tn >>= 1",
			"\t\tb *= b",
			"\t}",
			"\treturn res",
			"}",
			"func sum(s ...int) int {",
			"\tres := 0",
			"\tfor _, v := range s {",
			"\t\tres += v",
			"\t}",
			"\treturn res",
			"}",
			"func checkPrime(a int) bool {",
			"\tif a == 2 {",
			"\t\treturn true",
			"\t} else if a%2 == 0 {",
			"\t\treturn false",
			"\t}",
			"\tres := true",
			"\tfor q := 3; q*q <= a; q += 2 {",
			"\t\tif a%q == 0 {",
			"\t\t\tres = false",
			"\t\t\tbreak",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"func toBInt(a int) *big.Int {",
			"\treturn big.NewInt(int64(a))",
			"}",
			"",
			"/*",
			"\tめも",
			"\tint(64)の最大値: 9223372036854775807 = (2^63 - 1)",
			"\t19桁",
			"\t10^18 < 2^60 < 2^63 < 10^19",
			"\t10^19 はintだとオーバーフローする",
			"",
			"\tsliceの長さ: 10^8程度までは許される",
			"\t型によるがそれ以上は Out of memory の危険がある",
			"",
			"\t1~nの和: {n*(n+1)}/2",
			"\t(1~nの平均値)*n を式変形したもの",
			"\t先に掛け算をすることで必ず2で割り切れる",
			"*/",
		],
	},

// math -------------------------------------------------------
	"simple math template for int": {
		// "prefix": "math",
		"body": [
			"// simple math funcs for int",
			"func max(as ...int) int {",
			"\tres := as[0]",
			"\tfor _, a := range as {",
			"\t\tif res < a {",
			"\t\t\tres = a",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"func min(as ...int) int {",
			"\tres := as[0]",
			"\tfor _, a := range as {",
			"\t\tif res > a {",
			"\t\t\tres = a",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"func chMax(a *int, b int) {",
			"\t*a = max(*a, b)",
			"}",
			"",
			"func chMin(a *int, b int) {",
			"\t*a = min(*a, b)",
			"}",
			"func abs(a int) int {",
			"\tif a < 0 {",
			"\t\treturn -a",
			"\t}",
			"\treturn a",
			"}",
			"func pow(a, n int) int {",
			"\tres := 1",
			"\tb := a",
			"\tfor n > 0 {",
			"\t\tif n&1 > 0 {",
			"\t\t\tres *= b",
			"\t\t}",
			"\t\tn >>= 1",
			"\t\tb *= b",
			"\t}",
			"\treturn res",
			"}",
			"func sum(s ...int) int {",
			"\tres := 0",
			"\tfor _, v := range s {",
			"\t\tres += v",
			"\t}",
			"\treturn res",
			"}",
			"func checkPrime(a int) bool {",
			"\tif a == 2 {",
			"\t\treturn true",
			"\t} else if a%2 == 0 {",
			"\t\treturn false",
			"\t}",
			"\tres := true",
			"\tfor q := 3; q*q <= a; q += 2 {",
			"\t\tif a%q == 0 {",
			"\t\t\tres = false",
			"\t\t\tbreak",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"func toBInt(a int) *big.Int {",
			"\treturn big.NewInt(int64(a))",
			"}",
		],
	},
	"prime number tools": {
		"prefix": "primeTools",
		"body": [
			"// 整数系の問題を解くツール",
			"func gcd(a, b int) int {",
			"\tfor a%b != 0 {",
			"\t\ta, b = b, (a % b)",
			"\t}",
			"\treturn b",
			"}",
			"func lcm(a, b int) int {",
			"\treturn a/gcd(a, b)*b",
			"}",
			"func sieveOfEratosthenes(n int) []bool {",
			"\tbs := makeBools(n+1, true)",
			"\tbs[0], bs[1] = false, false",
			"\tfor p := 2; p <= n; p++ {",
			"\t\tif !bs[p] {",
			"\t\t\tcontinue",
			"\t\t}",
			"\t\tfor x := p * p; x <= n; x += p {",
			"\t\t\tbs[x] = false",
			"\t\t}",
			"\t}",
			"\treturn bs",
			"}",
			"func primeFactorization(n int) map[int]int {",
			"\tm := make(map[int]int)",
			"\tfor n%2 == 0 {",
			"\t\tn /= 2",
			"\t\tm[2]++",
			"\t}",
			"\tfor i := 3; i*i <= n; i += 2 {",
			"\t\tfor n%i == 0 {",
			"\t\t\tn /= i",
			"\t\t\tm[i]++",
			"\t\t}",
			"\t}",
			"\tif n != 1 {",
			"\t\tm[n]++",
			"\t}",
			"\treturn m",
			"}",
		],
	},
	"basic modulo template": {
		"prefix": "modulo",
		"body": [
			"// modulo tools",
			"type modulus int",
			"",
			"const defaultModP = int(1e9) + 7",
			"",
			"func newModulus(p int) *modulus {",
			"\tm := modulus(p)",
			"\treturn &m",
			"}",
			"func (m *modulus) mod(a int) int {",
			"\tif a < 0 || a >= int(*m) {",
			"\t\ta %= int(*m)",
			"\t}",
			"\tif a < 0 {",
			"\t\ta += int(*m)",
			"\t}",
			"\treturn a",
			"}",
			"func (m *modulus) add(a, b int) int { return m.mod(a + b) }",
			"func (m *modulus) sub(a, b int) int { return m.mod(a - b) }",
			"func (m *modulus) mul(a, b int) int { return m.mod(a * b) }",
			"func (m *modulus) div(a, b int) int { return m.mul(a, m.inv(b)) }",
			"func (m *modulus) inv(a int) int {",
			"\tx, _ := extGcd(a, int(*m))",
			"\treturn x",
			"}",
			"func (m *modulus) pow(a, n int) int {",
			"\tres := 1",
			"\tb := m.mod(a)",
			"\tfor n > 0 {",
			"\t\tif n&1 > 0 {",
			"\t\t\tres = m.mul(res, b)",
			"\t\t}",
			"\t\tn >>= 1",
			"\t\tb = m.mul(b, b)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func extGcd(a, b int) (int, int) {",
			"\tx0, y0 := 1, 0",
			"\tx1, y1 := 0, 1",
			"\tfor a%b != 0 {",
			"\t\tq := a / b",
			"\t\tr := a % b",
			"\t\tx2, y2 := x0-q*x1, y0-q*y1",
			"",
			"\t\ta, b = b, r",
			"\t\tx0, y0 = x1, y1",
			"\t\tx1, y1 = x2, y2",
			"\t}",
			"\treturn x1, y1",
			"}",
		],
	},
	"combination(mod m) template": {
		"prefix": "combinationForSmallK",
		"body": [
			"// combination mod m",
			"// ループがk回回ります",
			"func (m *modulus) combSmallK(n, k int) int {",
			"\tk = min(k, n-k)",
			"\ta, b := 1, 1",
			"\tfor i := 0; i < k; i++ {",
			"\t\ta = m.mul(a, n-i)",
			"\t\tb = m.mul(b, i+1)",
			"\t}",
			"\tres := m.div(a, b)",
			"\treturn res",
			"}",
		],
	},
	"combination(mod m) pre-calculator": {
		"prefix": "combinationPreCalc",
		"body": [
			"// 以下のサイト様のアルゴリズムを真似させていただきました",
			"// https://drken1215.hatenablog.com/entry/2018/06/08/210000",
			"func (mAddr *modulus) newCombinationCalculator(n int) (func(n, k int) int, struct{ fac, finv, inv []int }) {",
			"\tm := int(*mAddr)",
			"\tn++",
			"\tfac := make([]int, n)",
			"\tfinv := make([]int, n)",
			"\tinv := make([]int, n)",
			"\tfac[0], fac[1] = 1, 1",
			"\tfinv[0], finv[1] = 1, 1",
			"\tinv[1] = 1",
			"\tfor i := 2; i < n; i++ {",
			"\t\tfac[i] = fac[i-1] * i % m",
			"\t\tinv[i] = m - inv[m%i]*(m/i)%m",
			"\t\tfinv[i] = finv[i-1] * inv[i] % m",
			"\t}",
			"",
			"\tf := func(n, k int) int {",
			"\t\tif (n < k) || (n < 0) || (k < 0) {",
			"\t\t\treturn 0",
			"\t\t}",
			"\t\treturn fac[n] * (finv[k] * finv[n-k] % m) % m",
			"\t}",
			"\ts := struct {",
			"\t\tfac  []int",
			"\t\tfinv []int",
			"\t\tinv  []int",
			"\t}{fac, finv, inv}",
			"\treturn f, s",
			"}",
		],
	},
	"sieve of eratosthenes": {
		// "prefix": "eratosthenes",
		"body": [
			"func sieveOfEratosthenes(n int) []bool {",
			"\tbs := makeBools(n+1, true)",
			"\tbs[0], bs[1] = false, false",
			"\tfor p := 2; p <= n; p++ {",
			"\t\tif !bs[p] {",
			"\t\t\tcontinue",
			"\t\t}",
			"\t\tfor x := p * p; x <= n; x += p {",
			"\t\t\tbs[x] = false",
			"\t\t}",
			"\t}",
			"\treturn bs",
			"}",
		],
	},
	"greatest common divisor": {
		// "prefix": "gcd",
		"body": [
			"func gcd(a, b int) int {",
			"\tfor a%b != 0 {",
			"\t\ta, b = b, (a % b)",
			"\t}",
			"\treturn b",
			"}",
		],
	},

// data structure -------------------------------------------------------
	"union find tree": {
		"prefix": "unionFindTree",
		"body": [
			"// UnionFind Tree",
			"type unionFindTree struct {",
			"\t// 備忘録",
			"\t// 根となる頂点の要素には、特別に以下のような数値が格納されています。",
			"\t// 「その根が含まれている木」に含まれる頂点の数にマイナスをかけたもの",
			"\tparent []int",
			"\t// 連結成分の個数です",
			"\tcnt int",
			"}",
			"",
			"func newUnionFindTree(n int) *unionFindTree {",
			"\tuf := new(unionFindTree)",
			"\tuf.parent = make([]int, n)",
			"\tfor i := range uf.parent {",
			"\t\tuf.parent[i] = -1",
			"\t}",
			"\tuf.cnt = n",
			"\treturn uf",
			"}",
			"func (uf *unionFindTree) findRoot(a int) int {",
			"\tif uf.parent[a] < 0 {",
			"\t\treturn a",
			"\t}",
			"\tuf.parent[a] = uf.findRoot(uf.parent[a])",
			"\treturn uf.parent[a]",
			"}",
			"func (uf *unionFindTree) unite(a, b int) bool {",
			"\tx, y := uf.findRoot(a), uf.findRoot(b)",
			"\tif x == y {",
			"\t\treturn false",
			"\t}",
			"\tif uf.size(x) < uf.size(y) {",
			"\t\tx, y = y, x",
			"\t}",
			"\tuf.parent[x] += uf.parent[y]",
			"\tuf.parent[y] = x",
			"\tuf.cnt--",
			"\treturn true",
			"}",
			"func (uf *unionFindTree) sameRoot(a, b int) bool {",
			"\treturn uf.findRoot(a) == uf.findRoot(b)",
			"}",
			"func (uf *unionFindTree) size(a int) int {",
			"\treturn -uf.parent[uf.findRoot(a)]",
			"}",
		],
	},
	"simple queue for int": {
		"prefix": "queueForInt",
		"body": [
			"type intQueue []int",
			"",
			"func newIntQueue(cap int) *intQueue {",
			"\tres := make(intQueue, 0, cap)",
			"\treturn &res",
			"}",
			"func (q *intQueue) enqueue(a int) { *q = append(*q, a) }",
			"func (q *intQueue) dequeue() int {",
			"\tif len(*q) == 0 {",
			"\t\tprintln(\"!!!!!!qが空だからdequeueできません!!!!!!\")",
			"\t\tos.Exit(1)",
			"\t}",
			"\tres := (*q)[0]",
			"\t*q = (*q)[1:]",
			"\treturn res",
			"}",
			"func (q *intQueue) len() int { return len(*q) }",
		]
	},
	"simple stack for int": {
		"prefix": "stackForInt",
		"body": [
			"type intStack []int",
			"",
			"func newIntStack(cap int) *intStack {",
			"\tres := make(intStack, 0, cap)",
			"\t\treturn &res",
			"}",
			"func (s *intStack) push(a int) { *s = append(*s, a) }",
			"func (s *intStack) pop() int {",
			"\tif s.len() == 0 {",
			"\t\tprintln(\"!!!!!!sが空だからpopできません!!!!!!\")",
			"\t\tos.Exit(1)",
			"\t}",
			"\tres := (*s)[s.len()-1]",
			"\t*s = (*s)[:s.len()-1]",
			"\treturn res",
			"}",
			"func (s *intStack) len() int { return len(*s) }",
		],
	},
	"permutation library":{
		"prefix": "permutation",
		"body": [
			"type permutation []int",
			"",
			"func newPermutation(n int) permutation {",
			"\tp := make(permutation, n)",
			"\tfor i := 0; i < n; i++ {",
			"\t\tp[i] = i",
			"\t}",
			"\treturn p",
			"}",
			"",
			"func newPermutationInitialized(s []int) permutation {",
			"\treturn permutation(s)",
			"}",
			"",
			"func (p permutation) next() bool {",
			"\treturn p._doPermutation_(func(a, b int) bool { return a < b })",
			"}",
			"",
			"func (p permutation) prev() bool {",
			"\treturn p._doPermutation_(func(a, b int) bool { return a > b })",
			"}",
			"",
			"func (p permutation) _doPermutation_(cmp func(int, int) bool) bool {",
			"\tn := len(p)",
			"\tidx := -1",
			"\tfor i := n - 2; i >= 0; i-- {",
			"\t\tif cmp(p[i], p[i+1]) {",
			"\t\t\tidx = i",
			"\t\t\tbreak",
			"\t\t}",
			"\t}",
			"\tif idx == -1 {",
			"\t\treturn false",
			"\t}",
			"",
			"\tfor l, r := idx+1, n-1; l < r; {",
			"\t\tp[l], p[r] = p[r], p[l]",
			"\t\tl++",
			"\t\tr--",
			"\t}",
			"\tfor i := idx + 1; i < n; i++ {",
			"\t\tif cmp(p[idx], p[i]) {",
			"\t\t\tp[idx], p[i] = p[i], p[idx]",
			"\t\t\tbreak",
			"\t\t}",
			"\t}",
			"\treturn true",
			"}",
		]
	},
	"int segment tree": {
		"prefix": "segmentTree",
		"body": [
			"// 参考",
			"// https://maspypy.com/segment-tree-%e3%81%ae%e3%81%8a%e5%8b%89%e5%bc%b71",
			"// https://github.com/ktateish/go-competitive/blob/master/ac_segtree.go2",
			"// https://github.com/monkukui/ac-library-go/blob/master/segtree/segtree.go",
			"// https://atcoder.github.io/ac-library/master/document_ja/segtree.html",
			"type intSegmentTree struct {",
			"\tn         int                // len(初期化時に渡したスライス)",
			"\tdata      []int              // セグメントツリーの本体",
			"\toperation func(int, int) int // モノイド積(?)を計算する関数",
			"\tunit      int                // 単位元",
			"}",
			"",
			"func newIntSegmentTree(s []int, op func(int, int) int, unit int) *intSegmentTree {",
			"\tsg := &intSegmentTree{",
			"\t\tn:         len(s),",
			"\t\tdata:      make([]int, len(s)*2),",
			"\t\toperation: op,",
			"\t\tunit:      unit,",
			"\t}",
			"\tfor i := 0; i < sg.n; i++ {",
			"\t\tsg.data[i] = sg.unit",
			"\t}",
			"\tfor i, num := range s {",
			"\t\tsg.data[i+sg.n] = num",
			"\t}",
			"\tfor i := sg.n - 1; i >= 1; i-- {",
			"\t\tsg._update_(i)",
			"\t}",
			"\treturn sg",
			"}",
			"",
			"func (sg *intSegmentTree) set(idx, num int) {",
			"\tnow := sg.n + idx",
			"\tsg.data[now] = num",
			"\tfor now > 1 {",
			"\t\tnow /= 2",
			"\t\tsg._update_(now)",
			"\t}",
			"}",
			"",
			"func (sg *intSegmentTree) get(idx int) int {",
			"\treturn sg.data[sg.n+idx]",
			"}",
			"",
			"func (sg *intSegmentTree) product(l, r int) int {",
			"\tl += sg.n",
			"\tr += sg.n",
			"\tvalL, valR := sg.unit, sg.unit",
			"\tfor l < r {",
			"\t\tif l%2 == 1 {",
			"\t\t\tvalL = sg.operation(valL, sg.data[l])",
			"\t\t\tl++",
			"\t\t}",
			"\t\tif r%2 == 1 {",
			"\t\t\tr--",
			"\t\t\tvalR = sg.operation(sg.data[r], valR)",
			"\t\t}",
			"\t\tl /= 2",
			"\t\tr /= 2",
			"\t}",
			"\treturn sg.operation(valL, valR)",
			"}",
			"",
			"func (sg *intSegmentTree) productAll() int {",
			"\treturn sg.product(0, sg.n)",
			"}",
			"",
			"func (sg *intSegmentTree) _update_(now int) {",
			"\tchild1, child2 := now*2, now*2+1",
			"\tsg.data[now] = sg.operation(sg.data[child1], sg.data[child2])",
			"}",			
		],
	},

	"int ordered map(GoDS)": {
		"prefix": "intOrderedMap",
		"body": [
			"type intOrderedMap struct {",
			"\t_tm_ *treemap.Map",
			"}",
			"",
			"func newOrderedMapWithIntComparator() *intOrderedMap {",
			"\treturn &intOrderedMap{_tm_: treemap.NewWithIntComparator()}",
			"}",
			"",
			"// wrapper for treemap.Map#Put",
			"func (m *intOrderedMap) put(key, val int) {",
			"\tm._tm_.Put(key, val)",
			"}",
			"",
			"// wrapper for treemap.Map#Get",
			"// return 0 if key is not found.",
			"func (m *intOrderedMap) get(key int) int {",
			"\tval, found := m._tm_.Get(key)",
			"\tres := 0",
			"\tif found {",
			"\t\tres += val.(int)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"func (m *intOrderedMap) contains(key int) bool {",
			"\t_, found := m._tm_.Get(key)",
			"\treturn found",
			"}",
			"",
			"// wrapper for treemap.Map#Remove",
			"func (m *intOrderedMap) remove(key int) {",
			"\tm._tm_.Remove(key)",
			"}",
			"",
			"// wrapper for treemap.Map#Size",
			"func (m *intOrderedMap) size() int {",
			"\treturn m._tm_.Size()",
			"}",
			"",
			"// wrapper for treemap.Map#Keys",
			"func (m *intOrderedMap) keys() []int {",
			"\tkeys := m._tm_.Keys()",
			"\tres := make([]int, len(keys))",
			"\tfor i, key := range keys {",
			"\t\tres[i] = key.(int)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"// wrapper for treemap.Map#Values",
			"func (m *intOrderedMap) values() []int {",
			"\tvals := m._tm_.Values()",
			"\tres := make([]int, len(vals))",
			"\tfor i, val := range vals {",
			"\t\tres[i] = val.(int)",
			"\t}",
			"\treturn res",
			"}",
			"",
			"// wrapper for treemap.Map#Min",
			"func (m *intOrderedMap) min() (key, val int) {",
			"\tki, vi := m._tm_.Min()",
			"\treturn ki.(int), vi.(int)",
			"}",
			"",
			"// wrapper for treemap.Map#Max",
			"func (m *intOrderedMap) max() (key, val int) {",
			"\tki, vi := m._tm_.Max()",
			"\treturn ki.(int), vi.(int)",
			"}",
			"",
			"// wrapper for treemap.Map#Floor",
			"func (m *intOrderedMap) floor(key int) (foundKey, foundVal int, found bool) {",
			"\tki, vi := m._tm_.Floor(key)",
			"\tif ki == nil {",
			"\t\treturn 0, 0, false",
			"\t}",
			"\treturn ki.(int), vi.(int), true",
			"}",
			"",
			"// wrapper for treemap.Map#Ceiling",
			"func (m *intOrderedMap) ceiling(key int) (foundKey, foundVal int, found bool) {",
			"\tki, vi := m._tm_.Ceiling(key)",
			"\tif ki == nil {",
			"\t\treturn 0, 0, false",
			"\t}",
			"\treturn ki.(int), vi.(int), true",
			"}",
			"",
			"func (m *intOrderedMap) add(key, diff int) {",
			"\tval := m.get(key) + diff",
			"\tm.put(key, val)",
			"}",
			"",
			"func (m *intOrderedMap) decrement(key int) {",
			"\tm.add(key, -1)",
			"}",
			"",
			"func (m *intOrderedMap) increment(key int) {",
			"\tm.add(key, 1)",
			"}",
			"",
			"type iteratorForIntOrderedMap struct {",
			"\t_iter_ treemap.Iterator",
			"}",
			"",
			"// wrapper for treemap.Map#Iterator",
			"func (m *intOrderedMap) iterator() iteratorForIntOrderedMap {",
			"\treturn iteratorForIntOrderedMap{_iter_: m._tm_.Iterator()}",
			"}",
			"",
			"// wrapper for treemap.Iterator#Next",
			"func (iter *iteratorForIntOrderedMap) next() bool {",
			"\treturn iter._iter_.Next()",
			"}",
			"",
			"// wrapper for treemap.Iterator#Prev",
			"func (iter *iteratorForIntOrderedMap) prev() bool {",
			"\treturn iter._iter_.Prev()",
			"}",
			"",
			"// wrapper for treemap.Iterator#Key",
			"func (iter *iteratorForIntOrderedMap) key() int {",
			"\treturn iter._iter_.Key().(int)",
			"}",
			"",
			"// wrapper for treemap.Iterator#Value",
			"func (iter *iteratorForIntOrderedMap) value() int {",
			"\treturn iter._iter_.Value().(int)",
			"}",
		]
	},

// template that make coding easier -------------------------------------------------------
	"run length encoding": {
		"prefix": "runLengthEncoding",
		"body": [
			"func runLengthEncoding(s []rune) (res []struct {",
			"\tr   rune",
			"\tlen int",
			"}) {",
			"\tfor _, r := range s {",
			"\t\tn := len(res)",
			"\t\tif (n > 0) && res[n-1].r == r {",
			"\t\t\tres[n-1].len++",
			"\t\t} else {",
			"\t\t\tres = append(res, struct {",
			"\t\t\t\tr   rune",
			"\t\t\t\tlen int",
			"\t\t\t}{r, 1})",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",			
		],
	},
	"search all bit string": {
		"prefix": "searchAllBitString",
		"body": [
			"// bit全探索",
			"// for文で実装する元気がない時に使えます",
			"// for文のように振る舞います",
			"// 関数fの内でreturnするとcontinueのような動作になる",
			"// この関数ではbreakのような動作は再現できない",
			"func searchAllBitString(keta int, f func(bit int)) {",
			"\tn := 1 << keta",
			"\tfor bit := 0; bit < n; bit++ {",
			"\t\tf(bit)",
			"\t}",
			"}",
			"",
			"// 引数の関数fの内でreturn trueをするとbreakすることが可能",
			"// ただしbreakする必要がないときでもreturn falseと書かないといけない",
			"func searchAllBitStringBreakable(keta int, f func(bit int) (breaking bool)) {",
			"\tn := 1 << keta",
			"\tfor bit := 0; bit < n; bit++ {",
			"\t\tif f(bit) {",
			"\t\t\tbreak",
			"\t\t}",
			"\t}",
			"}",
		],
	},
	"grid tools": {
		"prefix": "grid",
		"body": [
			"// tools to solve grid problems",
			"type grid struct {",
			"\t_contents [][]rune",
			"\t_h, _w    int",
			"}",
			"type cell struct{ x, y int } // x: vertical, y: horizontal",
			"var (",
			"\tmove4Dir = [4]cell{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}",
			"\tmove8Dir = [8]cell{{1, 1}, {1, 0}, {1, -1}, {0, 1}, {0, -1}, {-1, 1}, {-1, 0}, {-1, -1}}",
			")",
			"",
			"func sumCells(c1, c2 cell) cell {",
			"\tx := c1.x + c2.x",
			"\ty := c1.y + c2.y",
			"\treturn cell{x, y}",
			"}",
			"func (sc *myScanner) getGrid(h, w int) *grid {",
			"\tg := new(grid)",
			"\tg._contents = make([][]rune, h)",
			"\tfor i := range g._contents {",
			"\t\tg._contents[i] = sc.getRunes()",
			"\t}",
			"\tg._h = h",
			"\tg._w = w",
			"\treturn g",
			"}",
			"func (g *grid) edit(c cell, r rune) {",
			"\tg._contents[c.x][c.y] = r",
			"}",
			"func (g *grid) referWithCell(c cell) rune {",
			"\treturn g.refer(c.x, c.y)",
			"}",
			"func (g *grid) refer(x, y int) rune {",
			"\treturn g._contents[x][y]",
			"}",
			"func (g *grid) inRange(c cell) bool {",
			"\tif c.x < 0 || c.y < 0 || c.x >= g._h || c.y >= g._w {",
			"\t\treturn false",
			"\t}",
			"\treturn true",
			"}",
			"func (g *grid) sliceVertical(start, end cell) []rune {",
			"\tif start.y != end.y {",
			"\t\tprintln(\"エラー発生: grid#sliceVertical\")",
			"\t\tprintln(\"!!!!!!開始地点と終了地点のy座標が違います!!!!!!\")",
			"\t\tos.Exit(1)",
			"\t}",
			"\tres := make([]rune, 0, end.x-start.x+1)",
			"\tfor i := start.x; i <= end.x; i++ {",
			"\t\tres = append(res, g.refer(i, start.y))",
			"\t}",
			"\treturn res",
			"}",
			"func (g *grid) sliceHorizontal(start, end cell) []rune {",
			"\tif start.x != end.x {",
			"\t\tprintln(\"エラー発生: grid#sliceHorizontal\")",
			"\t\tprintln(\"!!!!!!開始地点と終了地点のx座標が違います!!!!!!\")",
			"\t\tos.Exit(1)",
			"\t}",
			"\tres := make([]rune, end.y-start.y+1)",
			"\tcopy(res, g._contents[start.x][start.y : end.y+1])",
			"\treturn res",
			"}",
			"func (g *grid) countVertical(start, end cell, r rune) int {",
			"\tif start.y != end.y {",
			"\t\tprintln(\"エラー発生: grid#countVertical\")",
			"\t\tprintln(\"!!!!!!開始地点と終了地点のy座標が違います!!!!!!\")",
			"\t\tos.Exit(1)",
			"\t}",
			"\tres := 0",
			"\tfor i := start.x; i <= end.x; i++ {",
			"\t\tif g.refer(i, start.y) == r {",
			"\t\t\tres++",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"func (g *grid) countHorizontal(start, end cell, r rune) int {",
			"\tif start.x != end.x {",
			"\t\tprintln(\"エラー発生: grid#countHorizontal\")",
			"\t\tprintln(\"!!!!!!開始地点と終了地点のx座標が違います!!!!!!\")",
			"\t\tos.Exit(1)",
			"\t}",
			"\tres := 0",
			"\tfor i := start.y; i <= end.y; i++ {",
			"\t\tif g.refer(start.x, i) == r {",
			"\t\t\tres++",
			"\t\t}",
			"\t}",
			"\treturn res",
			"}",
			"",
			"type cellQueue []cell",
			"",
			"func newCellQueue(cap int) *cellQueue {",
			"\tres := make(cellQueue, 0, cap)",
			"\treturn &res",
			"}",
			"func (q *cellQueue) enqueue(c cell) {",
			"\t*q = append(*q, c)",
			"}",
			"func (q *cellQueue) dequeue() cell {",
			"\tif len(*q) == 0 {",
			"\t\tprintln(\"!!!!!!qが空だからdequeueできません!!!!!!\")",
			"\t\tos.Exit(1)",
			"\t}",
			"\tres := (*q)[0]",
			"\t*q = (*q)[1:]",
			"\treturn res",
			"}",
			"func (q *cellQueue) len() int { return len(*q) }",
		],
	},
}